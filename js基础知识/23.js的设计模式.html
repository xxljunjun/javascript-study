<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=s, initial-scale=1.0">
	<title>js的设计模式</title>
	<!-- <link rel="stylesheet" href=""> -->
</head>

<body>
	<script>
		/*
			js的设计模式
				==>学习设计模式，有助于写出可复用和可维护性高的程序
				==>设计模式的原则是“找出 程序中变化的地方，并将变化封装起来”，它的关键是意图，而不是结构。
				一、单例模式
					==>确保只有一个实例，并且提供全局访问
					==>var a = {},但是会造成全局污染

				二、策略模式
					==>策略模式的目的就是将算法的使用与算法的实现分离开来。
					==>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。
					==>策略模式含有不同的算法，做相同的事情；

				三、代理模式
					==>图片懒加载实现的过程就是通过代理模式中的虚拟代理来实现的
					==>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。

				四、迭代器模式
					==>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。
					==>for循环

				五、发布—订阅模式
					==>js事件就是经典的,vue中的双向数据绑定的原理
					==>发布-订阅模式里面包含了三个模块，发布者，订阅者和处理中心。

				六、命令模式
					==>命令模式中的命令(command)指的是一个执行某些特定事情的指令。
					==>通过不同的命令做不同的事情，常含有（关联）接收者。
					==>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化

				七、组合模式
					==>组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构。
					==>虚拟dom：将真实的DOM的数据抽取出来，以对象的形式模拟树形结构

				八、模板方法模式
					==>一种只需使用继承就可以实现的非常简单的模式。
                    ==>模板方法由两部分组成，一是抽象的父类，二是具体实现的子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。
                    typescript中就有abstract中的抽象类和抽象方法就是使用的模板方法模式

				九、装饰者模式
					==>允许向一个现有的对象添加新的功能，同时又不改变其结构。
					==>为对象添加新功能；不改变其原有的结构和功能
					==>ecorator 是 ES7 的一个新语法;装饰器语法

				十、职责链模式

				十一、中介者模式
	
				十三、状态模式

				十四、适配器模式

				十五、外观模式

				十六、享元模式
		*/
		//迭代器模式
			// ==>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。
			//==>遍历是最常用的
		//发布-订阅模式(观察者模式)
			//==>定义了对象间的一种一对多的依赖关系，当一个对象的状态发 生改变时，所有依赖于它的对象都将得到通知
			//==>JS中的事件就是经典的发布-订阅模式的实现
		//装饰者模式
			//以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。是一种“即用即付”的方式，能够在不改变对 象自身的基础上，在程序运行期间给对象动态地 添加职责


		//单例模式
			// ==>确保只有一个实例，并且提供全局访问
			// ==>var a = {},但是会造成全局污染
		var Single = (function () {
			var instance;
			function init() {
				// 定义私有方法和属性
				// 操作逻辑
				return {
					// 定义公共方法和属性
				};
			}
			return {
				// 获取实例
				getInstance: function () {
					if (!instance) {
						instance = init();
					}
					return instance;
				}
			}
		})();

		var obj1 = Single.getInstance();
		var obj2 = Single.getInstance();
		console.log(obj1 === obj2);

	</script>
</body>

</html>