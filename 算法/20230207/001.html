<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*
            我就是这样子的呀
            给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。

            你必须设计并实现一个时间复杂度为 O(n) 且仅使用常量额外空间的算法解决此问题。

             

            示例 1：

            输入：nums = [4,3,2,7,8,2,3,1]
            输出：[2,3]
            示例 2：

            输入：nums = [1,1,2]
            输出：[1]
            示例 3：

            输入：nums = [1]
            输出：[]
        */
      /**
       * @param {number[]} nums
       * @return {number[]}
       */
      var findDuplicates = function (nums) {
        //思路一：使用常量数据类型   12233478    只出现两次的话，就能看遍历这位和下一位是否相等来判断
        let str = nums.sort((a,b)=>a-b).join(',')  //43278231

        console.log(str.split(','))
        return str.split(',').filter((val,idx,arr)=>{
            return val == arr[idx+1]
        }) 
      };
      console.log('>>>',findDuplicates([10,2,5,10,9,1,1,4,3,7]))






    //   var findDuplicates = function (nums) {
    //     //思路一：使用额外空间引用数据类型
    //     let myMap = new Map()
    //     nums.forEach(val=>{
    //         if (myMap.has(val)) {
    //             myMap.set(val,myMap.get(val) + 1);
    //         } else {
    //             myMap.set(val, 1);
    //         }
    //     })
    //     console.log('>>>',myMap)
    //     let arr = []
    //     myMap.forEach((val,idx)=>{
    //         if(val ==2){
    //             arr.push(idx)
    //         }
    //     })
    //     return arr
    //   };
    //   console.log('>>>',findDuplicates([4,3,2,7,8,2,3,1]))
      
    </script>
  </body>
</html>
