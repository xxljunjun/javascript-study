<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。

            如果你可以删除 words[j] 最左侧和/或最右侧的若干字符得到 words[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。

             

            示例 1：

            输入：words = ["mass","as","hero","superhero"]
            输出：["as","hero"]
            解释："as" 是 "mass" 的子字符串，"hero" 是 "superhero" 的子字符串。
            ["hero","as"] 也是有效的答案。
            示例 2：

            输入：words = ["leetcode","et","code"]
            输出：["et","code"]
            解释："et" 和 "code" 都是 "leetcode" 的子字符串。
            示例 3：

            输入：words = ["blue","green","bu"]
            输出：[]
        */
       /**
 * @param {string[]} words
 * @return {string[]}
 */
var stringMatching = function(words) {
    // let arr = new Set()
    //  words.forEach((val,idx)=>{
    //     let fliterArr = words.filter(k=>{
    //         return k != val
    //     })
    //     for(let j = 0;j<fliterArr.length;j++){
    //         if(fliterArr[j].indexOf(val)>-1){
    //             arr.add(val)
    //         }
    //     }
    // })
    // return Array.from(arr)

    let strs = words.join(',');
    let res = [];
    for(let i=0;i<words.length;i++){
        let first = strs.indexOf(words[i]);
        let last = strs.lastIndexOf(words[i]);
        if(first != -1 && last != -1 && first != last){
            res.push(words[i])
        }
    }
    return res;
};
console.log(stringMatching(["leetcoder","leetcode","od","hamlet","am"]
)) //["as","hero"]
    </script>
</body>
</html>