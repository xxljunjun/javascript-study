
### CommonJS
+ 每一个文件就是一个模块
+ module变量代码当前模块
+ module.exports
+ exports和module.exports只能存在一个
+ require
+ CommonJS特点
```js
//特点
代码运行在模块作用域粒，不会污染全局作用域
模块可加载多次，只会在第一次加载时运行一次，运行结果有缓存
模块的加载顺序
模块输出的值是值的拷贝：从而控制了数据的访问权限
```
+ require的内部处理流程
```js
let person  = require('./person.js')
// 指向当前模块的module.require,再调用Node的内部命令  Module._load
Module._load = function(request,parent,isMain){
    //检查Module._cache,是否缓存中有指定的模块
    //没有就创建一个新的Module实例
    //保存到缓存中
    // 使用moduls.load()加载指定的模块文件;读取之后使用module.comile执行文件代码
    //加载报错就从缓存中删除该模块
    //返回该模块的module.exports
}
```
+ 想要再浏览器中使用commonjs
```js
//全局安装
npm install browserify
https://browserify.org/
browserify index.js -o bundle.js
```


### ESModule规范
+ AMD规范：异步模块定义
```
define()全局变量
提供定义模块及异步加载该模块依赖的机制
```
+ CMD规范：通用模块定义
```
define(require,exports，module)
异步加载，可以像再Node环境中一样来书写模块代码
```
+ ESModule规范
```js
//在编译阶段确定依赖关系和输入输出
export导出模块：export为普通导出，export default为默认导出
import加载模块

// 特点
每个模块加载一次，并执行一次，再次加载同一文件，直接从内存中读取
每个模块内声明的变量都是局部变量
export导出/import导入
ES6只支持静态导入和导出，只可以再模块的最外层作用域使用import和export
```
```js
//无论是用export还是用export default都放在NewPerson
import * as NewPerson from './person.js'

//异步
import('./person.js').then(res=>{
    console.log('xxxx',res)
})
console.log('111')

```

### ESModule和CommonJS的区别
CommonJS | ESModule
导出的是值的拷贝 | 导出的是值的引用
单个值导出 | 多个值导出
运行时加载 | 编译时加载
同步加载 | 支持同步和异步加载
模块中this指向当前模块 | 指向undefinded
```js
// type:"module"  //引入的时候要加上

//解决跨域
npm install http-server -g
http-server -p 80
```